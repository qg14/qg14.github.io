<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title></title>
</head>

<body>

    <script>
 /*
 斐波那契数列
 0,1,1,2,3,5,8,13,21,34,55，……
 该序列由前两项数值相加得成，斐波那契在1202年使用这个数列描述理想状态下兔子的增长
 
 */
//递归
       function recurFib(n){
           if(n<2){return n;}
           else{return recurFib(n-1)+recurFib(n-2);}
       }
//尾递归
/*
尾递归是一种可以避免不断的将函数压栈导致堆栈溢出的递归解决方案。他的技术原理是：在函数中return一个函数后，当前函数在栈内的调用记录会被删除，当前函数的执行上下文会从调用栈弹出。
*/
function tailRecurFib(n, sum1 = 1, sum2 = 1){
     if (n <= 1) return sum2;
     return Fibonacci(n - 1, sum2, sum1 + sum2)
}
//动态规划
//使用动态规划的算法从他能解决的最简单问题开始，继而通过得到的解，去解决其它更复杂的子问题，直到整个问题被解决
//所有的子问题的解通常被存储在一个数组中以便访问
function dynFib(n){
    var val=Array(n).fill(0);//使用数组val保留中间结果
    if(n==1||n==2){return 1;}
    else{
        val[1]=1;
        val[2]=2;
        for(var i=3;i<=n;++i){

            val[i]=val[i-1]+val[i+2];//将数组元素赋值为前两个之和
        }
        return val[n+1];
    }

}
//迭代版本的动态规划
function iterFib(n){
var last=1,nextLast=1;result=1;
for(var i=2;i<n;++i){

    result =last+nextLast;
    nextLast=last;
    last=result;
}
return result;

}

    </script>
</body>

</html>